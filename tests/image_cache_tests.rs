use kamachess::game::render_board_png;
use chess::Board;
use std::fs;
use std::path::Path;

#[test]
fn test_image_caching_lifecycle() {
    let board = Board::default();
    let fen = board.to_string();
    let safe_fen = fen.replace(['/', ' '], "_");
    let cache_dir = "images_cache";
    let file_path = format!("{}/{}.png", cache_dir, safe_fen);

    // Ensure clean state
    if Path::new(&file_path).exists() {
        fs::remove_file(&file_path).unwrap();
    }

    // 1. Generate image (should create cache file)
    let result = render_board_png(&board);
    assert!(result.is_ok(), "First render failed");
    assert!(Path::new(&file_path).exists(), "Cache file was not created");

    let first_metadata = fs::metadata(&file_path).unwrap();
    let first_modified = first_metadata.modified().unwrap();

    // 2. Render again (should use cache file)
    // Wait a tiny bit to ensure modification time would be different if rewritten
    std::thread::sleep(std::time::Duration::from_millis(10));

    let result_cached = render_board_png(&board);
    assert!(result_cached.is_ok(), "Second render failed");
    
    let second_metadata = fs::metadata(&file_path).unwrap();
    let second_modified = second_metadata.modified().unwrap();

    assert_eq!(first_modified, second_modified, "Cache file was modified, meaning it was likely regenerated instead of used");

    let bytes_original = result.unwrap();
    let bytes_cached = result_cached.unwrap();

    assert_eq!(bytes_original, bytes_cached, "Cached bytes differ from generated bytes");

    // Cleanup
    // We remove the file to leave the system clean, but we might want to keep it in a real scenario.
    // For tests, it's polite to clean up.
    let _ = fs::remove_file(file_path);
}
